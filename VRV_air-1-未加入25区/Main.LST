C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Main.C BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /***********************************************************************
   2          
   3                                ½ðÁê·¹µêºÍÌ¨Íå°´¼ü  ½Ó¿Ú³ÌÐò
   4          
   5            CPU       : CF340
   6            frequence : 12 MHZ
   7            
   8            Author    : Pan xiao bin
   9            Version   : 1.0
  10            Date      : 2011.12.10
  11            
  12            All rights reserved.
  13          
  14          **********************************************************************/
  15          #include "c8051F340.h"
  16          #include "Main.h"
  17          #include "cmd.h"
  18          
  19          
  20          //#include "c8051f340-modbus.h"
  21          
  22          void Delay(uchar n);
  23          void Delay_ms(uint n);
  24          void clear_wdt();
  25          
  26          
  27          
  28          
  29          unsigned char bdata Flag1;
  30          
  31          sbit keyaction      =Flag1^0;     
  32          sbit keyprese     =Flag1^1;
  33          sbit keyrelase      =Flag1^2;
  34          sbit sreceive     =Flag1^3;
  35          sbit Sreceiveend    =Flag1^4;
  36          sbit tranready      =Flag1^5;
  37          sbit command_echo   =Flag1^6; //command_echo =1Ê± ÐèÒªÓÐÓ¦´ð
  38          
  39          
  40          
  41          unsigned char bdata Flag2 = 0;
  42          sbit signal     =Flag2^0;   
  43          sbit setup_mode     =Flag2^1;
  44          sbit block_writer   =Flag2^2;
  45          sbit keyenable      =Flag2^3;
  46          sbit flag20ms     =Flag2^4;
  47          
  48          sbit resend_msg     =Flag2^6;
  49          
  50          
  51          unsigned char bdata Flag3;
  52          sbit ledon    =Flag3^0;
  53          sbit TIME_1MS   =Flag3^1;
  54          
  55          
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 2   

  56          
  57          unsigned char bdata Flag4;
  58          sbit tranbuffull_1  =Flag4^0;
  59          sbit sreceive_1   =Flag4^1;
  60          sbit sreceiveend_1  =Flag4^2;
  61          sbit servicesw    =Flag4^3;
  62          sbit tranready_1  =Flag4^4;
  63          
  64          sbit led_status   =Flag4^5;
  65          sbit TRFLAG   =Flag4^6;
  66          sbit serviceled   =Flag4^7;
  67          
  68          
  69          
  70          unsigned char bdata status =0;
  71          
  72          sbit  guest_IN  =status^2;
  73          sbit  all_off   =status^3;
  74          
  75          
  76          
  77          
  78          unsigned char data  RTC_BUF[4];
  79          unsigned char   xdata   *COM_buf_point;
  80          unsigned char   data  *COM1_buf_point;
  81          unsigned char   data  *COM1_buf_trce_point;
  82          
  83          unsigned char   data  netactivetime;
  84          unsigned char   data  second;
  85          unsigned char   data  box;
  86          unsigned char   data  time20ms;
  87          unsigned char   data  time20ms_out;
  88          
  89          unsigned char   data  COM0_length;
  90          unsigned int  xdata   eerom_address;
  91          
  92          
  93          //unsigned char   data  *eeprom_point;
  94          
  95          
  96          
  97          
  98          unsigned char   idata   receivetime_1;
  99          
 100          
 101          unsigned char   xdata BUF_RECE[180];
 102          unsigned char   data  BUF_RECE1[IN_LEN];
 103          unsigned char   data  BUF_TRCE1[IN_LEN];
 104          
 105          unsigned char   resend_msg_length=0;
 106          unsigned char   xdata resend_msg_buf[64];
 107          unsigned char   resend_msg_sec=0;
 108          unsigned char   resend_msg_counter=0;
 109          unsigned char   temp=0;
 110          unsigned char   xdata receive_length=0;
 111          unsigned char   xdata receivetime =0;
 112          
 113          unsigned char   xdata returne_air_mode[3];
 114          unsigned char   xdata returne_set_temperature[3];
 115          unsigned char   xdata returne_temperature[3];
 116          unsigned char   xdata returne_fan1_speed[3];
 117          unsigned char   xdata returne_fan2_speed[3];
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 3   

 118          
 119          unsigned char   xdata set_air_mode[3];
 120          unsigned char   xdata set_temperature[3];
 121          unsigned char   xdata set_fan1_speed[3];
 122          unsigned char   xdata set_fan2_speed[3];
 123          unsigned char   xdata   air_RQ_num = 0;
 124          
 125          /************* added by jin *************/
 126          uint16 xdata CRC_result,last_register_addr,temp_status;  //last_register_addr  ÓÃÀ´´æ´¢ÉÏ´Î·¢ËÍµÄ¼Ä´æÆ÷µØÖ
             -·
 127          uint8 xdata flag_1ms,PermitTrans,readySend,last_function_code,function_code_copy;//last_function_code ÓÃÀ´
             -´æ´SÉÏ´ÎÊ¹ÓÃµÄ¹¦ÄÜÂë
 128          uint8 xdata Modbus_Rcvd_Num,poling_mode,air_condi_num;                               
 129          uint8 xdata Modbus_Reg[85],status_connect[4],status_communication[4],air_box_num[64];
 130          //uint16 xdata svd_air_param[64][8];
 131          //uint16 xdata function_register[192];
 132          //uint16 xdata status_register[384];
 133          //uint16 xdata hold_register[193];
 134          uint16  xdata air_power[64];
 135          uint16  xdata shadow_power[64];
 136          uint16  xdata air_temperature[64];
 137          uint16  xdata air_mode[64];
 138          uint16  xdata air_speed[64];
 139          uint16  xdata actual_temperature[64];
 140          uint16  xdata RQ_address;
 141          
 142          uint8 bdata flag_state =0;
 143          sbit RQ_ST=flag_state^0;
 144          
 145          uint8 xdata Reg_temp[50];
 146          uint8 xdata roll_poling,roll_flag,flag_fisrt_run=1;
 147          uint32 xdata interval_ms;
 148          uint16 xdata last_reg_num;
 149          
 150          uint8 xdata station_ip,control_mode,actual_tempture[64],actual_tempture1;
 151          
 152          uint8 xdata status_adapter=0,resend_times;
 153          uint16 xdata temp_array[50];
 154          
 155          unsigned char bdata flag_air_sys=0;
 156          sbit status_initial       = flag_air_sys^0;   //ÊÊÅäÆ÷ÊÇ·ñ×¼±¸ºÃµÄ±êÖ¾
 157          sbit status_ctrl        = flag_air_sys^1;   //ÊÇ·ñÊÇ±¾Ä£¿éÔÚ¿ØÖÆµÄ±êÖ¾
 158          sbit status_check_function    = flag_air_sys^2;   //¼ì²é¹¦ÄÜ±êÖ¾Î»
 159          sbit status_vrv_pointed     = flag_air_sys^3;   //vrvµØÖ·ÊÇ·ñÍ¨¹ýµ÷ÊÔÈí¼þÖ¸ÅÉÁË
 160          sbit status_cmd_ack       =   flag_air_sys^4;   //ÃüÁîÊÇ·ñÈ·ÈÏ
 161          sbit status_no_other_dakin_vrv  = flag_air_sys^5;   //ÊÇ·ñ´æÔÚÓÐÆäËûµÄVRVÄ£¿é
 162          sbit status_device_first_run  = flag_air_sys^6;   //Éè±¸ÊÇ·ñÊ×´ÎÆô¶¯
 163          sbit status_repeat_0x06     = flag_air_sys^7;   //0x06µÄÃüÁîÊÇ·ñÖØ¸´
 164          
 165          unsigned char bdata flag_sys_status=0;
 166          sbit status_ctrl_cmd_sent   = flag_sys_status^0;
 167          sbit status_reply_flag      = flag_sys_status^1;
 168          sbit flag_1s          = flag_sys_status^2;
 169          sbit flag_inc         = flag_sys_status^3;
 170          
 171          typedef enum haier_state
 172          {
 173            requesting = 0,
 174            sending,
 175            ST_onoff,    // 0 ¹Ø 1¿ª
 176            ST_mode,       // 0 ×Ô¶¯ 1ËÍ·ç 2ÖÆÀä 3³ýÊª 4ÖÆÈÈ
 177            ST_temperature,// 16~30
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 4   

 178            ST_speed,      // 0 ×Ô¶¯ 1µÍ·ç 2ÖÐ·ç 3¸ß·ç
 179            RQ_onoff,
 180            RQ_mode,
 181            RQ_temperature,
 182            RQ_speed,
 183            RQ_out_state
 184          }haier_state_machine;   
 185          
 186          haier_state_machine modbus_state;
 187          haier_state_machine state_copy; 
 188          uint16 last_address;                               
 189          
 190          /***************************************/
 191          
 192          void Timer_Init()
 193          {
 194   1        TCON=0x10;
 195   1        TMOD=0x21;
 196   1        //CKCON=000; 2400
 197   1        TL0=0xA0;
 198   1        TH0=0xA0;
 199   1        //TH1=0x30; 2400
 200   1         
 201   1        CKCON=0x01;
 202   1      //  TH1 = 0XB2;
 203   1        TH1=0x64;   //9600
 204   1      //  TH1=0X98;  //4800bps
 205   1      }
 206          
 207          void UART_Init()
 208          {
 209   1      //  SCON0 =0x10; //Ô­À´µÄÉèÖÃ
 210   1        SCON0 =0X90; //9Î»Êý¾Ý
 211   1        SBRLL1  =0x8F;
 212   1        SBRLH1  =0xFD;
 213   1        SCON1 =0x10;
 214   1        SBCON1  =0x43;  
 215   1      }
 216          
 217          
 218          
 219          void  Port_IO_Init()
 220          {
 221   1            P0SKIP    = 0xCF;
 222   1            XBR0      = 0x01;
 223   1            XBR1      = 0x40;
 224   1            XBR2      = 0x01;
 225   1      
 226   1      }
 227          
 228          void  Oscillator_Init()
 229          {
 230   1        uchar i;
 231   1              OSCICN=0x83;
 232   1        CLKMUL=0x80;
 233   1            Delay(255);
 234   1            CLKMUL |=0xC0;
 235   1              do
 236   1              {       i=(CLKMUL &0x20);
 237   2              }while(!i);
 238   1      /*Osc_Wait2:
 239   1          mov  A,         CLKMUL
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 5   

 240   1          jnb  ACC.5,     Osc_Wait2*/
 241   1      }
 242          
 243          void  Interrupts_Init()
 244          {
 245   1            EIE1 =000;
 246   1            EIE2 =002;    //EIE2 =002;
 247   1          IE =0x92;
 248   1      }
 249          
 250          
 251          
 252          void Init_Device()
 253          {
 254   1        Timer_Init();
 255   1            UART_Init();
 256   1            //SPI_Init();
 257   1            Port_IO_Init();
 258   1            Oscillator_Init();
 259   1            Interrupts_Init();
 260   1      }
 261          
 262          void Delay(uchar n)
 263          {
 264   1        uchar i;
 265   1        for(i=0;i<n;i++);
 266   1      }
 267          
 268          void Delay_ms(uint n)
 269          {
 270   1        uint i;
 271   1        for(i=0;i<n;i++)Delay(80);
 272   1      }
 273          
 274          void clear_wdt() /*Çå¿´ÃÅ¹·*/
 275          {
 276   1              EA=0;
 277   1              ReadEE(0xff,1,RTC_BUF);
 278   1              EA=1;
 279   1      }
 280          
 281          /*¶¨Ê±Æ÷0 ÖÐ¶Ï·þÎñ³ÌÐò,ÓÃÓÚ1MS */
 282          void Service_Timer0() interrupt 1 using 1
 283          {
 284   1        TL0 = TL0_VAL;  
 285   1        TH0 = TH0_VAL;
 286   1        TIME_1MS = 1;
 287   1      
 288   1        flag_1ms++;
 289   1        interval_ms++;
 290   1        /*
 291   1        if(sreceive)
 292   1        {
 293   1          if(receivetime >8 )
 294   1          {
 295   1            sreceive = 0;
 296   1            receivetime = 0;
 297   1            OE0 = 1;
 298   1            REN0 = 1;
 299   1            TI0 = 0;
 300   1            receive_length =0;
 301   1          }
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 6   

 302   1          else  receivetime ++;
 303   1        }
 304   1        */
 305   1        if(sreceive_1)
 306   1        {
 307   2          if(receivetime_1 > 4)
 308   2          {
 309   3            sreceive_1 = 0;
 310   3            receivetime_1 = 0;
 311   3            OE1 = 1;
 312   3            SCON1 |=0x10;
 313   3            SCON1&=~(0x02);
 314   3          }
 315   2          else  receivetime_1++;
 316   2        }
 317   1      
 318   1      }
 319          
 320          /********** added by jin******************************************/
 321          
 322          /***********************
 323          * Modbus send :ÉèÖÃ·¢ËÍ±êÖ¾Î»£¬ÆäÖÐlength ±íÊ¾Òª·¢ËÍµÄ×Ö½ÚÊý
 324          *        PermitTrans=1±íÊ¾×ÜÏß¿ÕÏÐ£¬ÔÊÐí·¢ËÍ
 325          *        readySend=1Ê±±íÊ¾ÓÐÊý¾ÝÒª·¢ËÍ
 326          *   £¡£¡£¡   ·¢ËÍÇ°Ð´ºÃBUF_RECE    £¡£¡£¡
 327          ************************/
 328          void Modbus_Send(uint8 length)
 329          {
 330   1        COM0_length = length;
 331   1        PermitTrans = 0;
 332   1        readySend = 1;  
 333   1      }
 334          
 335          /**********************************
 336          * CRC_CHK:crc_16 Ð£Ñé³ÌÐò  *pDataÎªÒªÐ£ÑéµÄÊý×é
 337          *              nLen ±íÊ¾ÒªÐ£ÑéµÄ³¤¶È
 338          *£¡£¡£¡       Ê¹ÓÃÊ±ÐèÒª×¢Òâ·¢ËÍÊ±µÍÎ»ÔÚÇ°»¹ÊÇ¸ßÎ»ÔÚÇ°   £¡£¡£¡
 339          ***********************************/
 340          // uint16 crc_chk(uint8 *pData,uint8 nLen)
 341          // {
 342          // uint16 temp_crc=0xffff,temp1,i,j;
 343          //  for(i=0;i<nLen;i++)
 344          //     {
 345          //     temp_crc^=*(pData+i);
 346          //  for(j=0;j<8;j++)
 347          //    {
 348          //    temp1=temp_crc;
 349          //    temp_crc>>=1;
 350          //    if(temp1&0x0001)
 351          //      temp_crc^=0xa001;
 352          //         }
 353          //     }
 354          // return(temp_crc);
 355          // }                          
 356          
 357          
 358          uint8 code auchCRCHi[]=
 359          {
 360          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
 361          0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
 362          0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
 363          0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 7   

 364          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
 365          0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
 366          0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
 367          0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
 368          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
 369          0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
 370          0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
 371          0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 372          0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
 373          0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
 374          0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
 375          0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
 376          0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
 377          0x40
 378          };
 379          
 380          uint8 code auchCRCLo[] =
 381          {
 382          0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
 383          0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
 384          0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
 385          0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
 386          0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
 387          0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
 388          0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
 389          0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
 390          0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
 391          0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
 392          0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
 393          0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
 394          0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
 395          0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
 396          0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
 397          0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
 398          0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
 399          0x40
 400          };
 401          
 402          uint16 crc_chk(uint8 *pData,uint8 nLen)
 403          {
 404   1        uint8 uchCRCHi=0xff;
 405   1        uint8 uchCRCLo=0xff;
 406   1        uint16  uindex;
 407   1        while(nLen--)
 408   1        {
 409   2          uindex=uchCRCHi^*pData++;
 410   2          uchCRCHi=uchCRCLo^auchCRCHi[uindex];
 411   2          uchCRCLo=auchCRCLo[uindex];
 412   2        }
 413   1        return (((uint16) uchCRCLo)<<8|uchCRCHi);
 414   1      }
 415          
 416          
 417          /*************************************************************/
 418          void init_Modbus_Reg(void)
 419          {
 420   1        uint16 index;
 421   1        for(index=0;index<64;index++)
 422   1        {
 423   2          air_power[index]=0;
 424   2          air_mode[index] = 0;
 425   2          air_speed[index]= 0;
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 8   

 426   2          actual_temperature[index] = 20;
 427   2          air_temperature[index] = 25;
 428   2        }
 429   1      
 430   1      }
 431          
 432          /*******  added @2012-12-14   *************/
 433          /*  the following codes are designed to   */
 434          /*  convert LDS Protocol to Haier modbus  */
 435          /*  Protoclol                 */
 436          /*******  added @2012-12-14   *************/
 437          void RQ_air_condi( uint16 air_num,uint8 reg_num )
 438          {
 439   1      
 440   1      //  requesting = 0,
 441   1      //  sending,
 442   1      //  ST_onoff,    // 0 ¹Ø 1¿ª
 443   1      //  ST_mode,       // 0 ×Ô¶¯ 1ËÍ·ç 2ÖÆÀä 3³ýÊª 4ÖÆÈÈ
 444   1      //  ST_temperature,// 16~30
 445   1      //  ST_speed,      // 0 ×Ô¶¯ 1µÍ·ç 2ÖÐ·ç 3¸ß·ç
 446   1      //  RQ_onoff,
 447   1      //  RQ_mode,
 448   1      //  RQ_temperature,
 449   1      //  RQ_speed,
 450   1      //  RQ_out_state
 451   1        uint16 address;
 452   1        if((air_num>64)||(reg_num>252))   return;
 453   1        if((reg_num==0))  return;
 454   1        
 455   1        BUF_RECE[0] = station_ip;
 456   1        switch(modbus_state)
 457   1        {
 458   2          case RQ_onoff:
 459   2          {
 460   3            BUF_RECE[1] = 0X02;   //¹¦ÄÜÂë
 461   3            address = air_num*152;
 462   3            RQ_address = address;
 463   3            BUF_RECE[4] = 0;
 464   3            BUF_RECE[5] = 8;
 465   3            modbus_state = RQ_mode;       
 466   3            break;
 467   3          }
 468   2          case RQ_mode:
 469   2          {
 470   3            BUF_RECE[1] = 0X02;   //¹¦ÄÜÂë
 471   3            address = air_num*152+8;
 472   3            RQ_address = address;
 473   3            BUF_RECE[4] = 0;
 474   3            BUF_RECE[5] = 8;
 475   3            modbus_state = RQ_temperature;        
 476   3            break;      
 477   3          }
 478   2          case RQ_temperature:
 479   2          {
 480   3            BUF_RECE[1] = 0X04;   //¹¦ÄÜÂë
 481   3            address = air_num*156;
 482   3            RQ_address = address;
 483   3            BUF_RECE[4] = 0;
 484   3            BUF_RECE[5] = 1;
 485   3            modbus_state = RQ_speed;        
 486   3            break;    
 487   3          }
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 9   

 488   2          case RQ_speed:
 489   2          {
 490   3            BUF_RECE[1] = 0X02;   //¹¦ÄÜÂë
 491   3            address = air_num*152+16;
 492   3            RQ_address = address;
 493   3            BUF_RECE[4] = 0;
 494   3            BUF_RECE[5] = 8;      
 495   3            modbus_state = RQ_onoff;
 496   3            break;    
 497   3      //          if(flag_inc)
 498   3      //          {
 499   3      //            air_RQ_num++;
 500   3      //          }
 501   3      //          for(;air_RQ_num<64;air_RQ_num++)
 502   3      //          {
 503   3      //            if(air_box_num[air_RQ_num]!=0)
 504   3      //            {
 505   3      //              flag_inc=1;
 506   3      //              break;
 507   3      //            }
 508   3      //          }
 509   3      //          if(air_RQ_num>=64)
 510   3      //          {
 511   3      //            air_RQ_num=0;
 512   3      //          }     
 513   3          }
 514   2          default:
 515   2          {
 516   3            BUF_RECE[1] = 0X02;   //¹¦ÄÜÂë
 517   3            address = air_num*152;
 518   3            RQ_address = address;
 519   3            BUF_RECE[4] = 0;
 520   3            BUF_RECE[5] = 8;
 521   3            modbus_state = RQ_mode;       
 522   3            break;
 523   3          }
 524   2        }
 525   1        BUF_RECE[2] = (uint8) (address>>8);
 526   1        BUF_RECE[3] = (uint8) address;
 527   1        RQ_address = address;
 528   1        address = crc_chk(BUF_RECE,6);
 529   1        BUF_RECE[7] = (uint8) (address>>8);
 530   1        BUF_RECE[6] = (uint8) address;
 531   1        Modbus_Send(7);
 532   1        
 533   1      } 
 534          
 535          void ST_air_condi(uint8 air_num,uint8 reg_num,uint8* param)
 536          {   
 537   1      //  requesting = 0,
 538   1      //  sending,
 539   1      //  ST_onoff,    // 0 ¹Ø 1¿ª
 540   1      //  ST_mode,       // 0 ×Ô¶¯ 1ËÍ·ç 2ÖÆÀä 3³ýÊª 4ÖÆÈÈ
 541   1      //  ST_temperature,// 16~30
 542   1      //  ST_speed,      // 0 ×Ô¶¯ 1µÍ·ç 2ÖÐ·ç 3¸ß·ç
 543   1      //  RQ_onoff,
 544   1      //  RQ_mode,
 545   1      //  RQ_temperature,
 546   1      //  RQ_speed,
 547   1      //  RQ_out_state
 548   1        uint8 i,j;
 549   1        uint8   get_param[10];
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 10  

 550   1        uint16 address,temperature;
 551   1        if((air_num>64)||(reg_num>252))
 552   1        {
 553   2          RQ_ST = 0;
 554   2          return;
 555   2        }
 556   1        if((reg_num==0))
 557   1        {
 558   2          RQ_ST = 0;
 559   2          return;
 560   2        }
 561   1        BUF_RECE[0] = station_ip;
 562   1      //  if((modbus_state==ST_onoff)&&(shadow_power[i] !=1))
 563   1      //  {
 564   1      //    
 565   1      //  }
 566   1        switch(modbus_state)
 567   1        {
 568   2          case ST_onoff:
 569   2          {
 570   3            BUF_RECE[1] = 0X0f;
 571   3            address = 152*air_num;
 572   3            //´Ë´¦ÐèÒªÌîÐ´Êý¾Ý
 573   3            if(param[0] ==0)
 574   3            {
 575   4              RQ_ST = 0;  
 576   4            }
 577   3      //      shadow_power[i] = 0;
 578   3            BUF_RECE[2] = (uint8) (address>>8);
 579   3            BUF_RECE[3] = (uint8) address;
 580   3            BUF_RECE[4] = 0;      
 581   3            BUF_RECE[5] = 0X08;
 582   3            BUF_RECE[6] = 0X01;
 583   3            BUF_RECE[7] = *param;
 584   3            address = crc_chk(BUF_RECE,8);
 585   3            BUF_RECE[8] = (uint8) address;
 586   3            BUF_RECE[9] = (uint8) (address>>8);
 587   3            Modbus_Send(9);     
 588   3            modbus_state = ST_mode;//Èç¹ûÊÇ¿ªµÄ×´Ì¬£¬ÉèÖÃÄ£Ê½
 589   3      //    modbus_state = state_copy;//Èç¹ûÊÇ¹ØµÄ×´Ì¬£¬Ö±½Ó»Ø²éÑ¯×´Ì¬µÄÄ£Ê½
 590   3            break;        
 591   3          }
 592   2          case ST_mode:
 593   2          {
 594   3            BUF_RECE[1] = 0X0f;
 595   3            address = 152*air_num+8;
 596   3            BUF_RECE[2] = (uint8) (address>>8);
 597   3            BUF_RECE[3] = (uint8) address;
 598   3            BUF_RECE[4] = 0;        
 599   3            BUF_RECE[5] = 0X08;
 600   3            BUF_RECE[6] = 0X01;
 601   3            BUF_RECE[7] = *(param+1);
 602   3            address = crc_chk(BUF_RECE,8);
 603   3            BUF_RECE[8] = (uint8) address;
 604   3            BUF_RECE[9] = (uint8) (address>>8);
 605   3            Modbus_Send(9); 
 606   3            modbus_state = ST_temperature;
 607   3            break;
 608   3          }
 609   2          case ST_temperature:
 610   2          {
 611   3            BUF_RECE[1] = 0X06;
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 11  

 612   3            address = 156*air_num;
 613   3            BUF_RECE[2] = (uint8) (address>>8);
 614   3            BUF_RECE[3] = (uint8) address;
 615   3            temperature = *(param+2);
 616   3            if(temperature>20)
 617   3            {
 618   4              temperature = temperature*50;
 619   4              temperature |=0x0800;
 620   4            }
 621   3            else
 622   3            {
 623   4              temperature = temperature*100;
 624   4            }
 625   3            BUF_RECE[5] = (uint8) temperature;
 626   3            BUF_RECE[4] = (uint8) (temperature>>8);     
 627   3            address = crc_chk(BUF_RECE,6);
 628   3            BUF_RECE[6] = (uint8) address;
 629   3            BUF_RECE[7] = (uint8) (address>>8);
 630   3            Modbus_Send(7);  
 631   3            modbus_state = ST_speed;
 632   3            break;
 633   3          }
 634   2          case ST_speed:
 635   2          {
 636   3            RQ_ST = 0;
 637   3            BUF_RECE[1] = 0X0f;
 638   3            address = 152*air_num+16;
 639   3            BUF_RECE[2] = (uint8) (address>>8);
 640   3            BUF_RECE[3] = (uint8) address;
 641   3            BUF_RECE[4] = 0;        
 642   3            BUF_RECE[5] = 0X08;
 643   3            BUF_RECE[6] = 0X01;
 644   3            BUF_RECE[7] = *(param+3);
 645   3            address = crc_chk(BUF_RECE,8);
 646   3            BUF_RECE[8] = (uint8) address;
 647   3            BUF_RECE[9] = (uint8) (address>>8);
 648   3            Modbus_Send(9); 
 649   3            break;
 650   3          }
 651   2          default:
 652   2          {
 653   3      //      RQ_ST = 0;
 654   3            modbus_state = ST_onoff;
 655   3      //      modbus_state = state_copy;
 656   3            return;
 657   3          }
 658   2        }
 659   1      
 660   1      
 661   1      
 662   1      }
*** WARNING C280 IN LINE 548 OF Main.C: 'i': unreferenced local variable
*** WARNING C280 IN LINE 548 OF Main.C: 'j': unreferenced local variable
*** WARNING C280 IN LINE 549 OF Main.C: 'get_param': unreferenced local variable
 663          
 664          void process_received( void )
 665          {
 666   1      //  RQ_onoff,
 667   1      //  RQ_mode,
 668   1      //  RQ_temperature,
 669   1      //  RQ_speed,
 670   1      //  ST_onoff,    // 0 ¹Ø 1¿ª
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 12  

 671   1      //  ST_mode,       // 0 ×Ô¶¯ 1ËÍ·ç 2ÖÆÀä 3³ýÊª 4ÖÆÈÈ
 672   1      //  ST_temperature,// 16~30
 673   1      //  ST_speed,      // 0 ×Ô¶¯ 1µÍ·ç 2ÖÐ·ç 3¸ß·ç
 674   1        
 675   1      // uint16   xdata air_power[64];
 676   1      // uint16   xdata air_temperature[64];
 677   1      // uint16   xdata air_mode[64];
 678   1      // uint16   xdata air_speed[64];
 679   1      // uint16   xdata actual_temperature[64]; 
 680   1        
 681   1      //  ÓÉÓÚ²éÑ¯ºóÖ±½Ó½«×´Ì¬»úÐÞ¸Ä³ÉÏÂÒ»×´Ì¬£¬½ÓÊÕÊ±²éÑ¯¸üÐÂÉÏÒÂ×´Ì¬µÄÖµ  
 682   1        uint8 i;
 683   1        uint16 address;
 684   1        if(BUF_RECE[1] == 0X02)
 685   1        {
 686   2          if((Modbus_Rcvd_Num-5)!=(BUF_RECE[2])) return;
 687   2          switch(modbus_state)
 688   2          {
 689   3            case RQ_onoff:    //Êµ¼ÊÎªµÈ´ý·çËÙµÄ×´Ì¬
 690   3            {
 691   4              i = BUF_RECE[3];
 692   4              switch(i)
 693   4              {
 694   5                case 1:       //·çËÙ¹Ø
 695   5                {
 696   6                  air_speed[RQ_address/152] = 0;
 697   6                  break;
 698   6                }
 699   5      //          case 2:       //·çËÙ×Ô¶¯
 700   5      //          {
 701   5      //            air_speed[RQ_address/152] = 4;
 702   5      //            break;
 703   5      //          }   
 704   5                case 3:       //·çËÙ¸ß
 705   5                {
 706   6                  air_speed[RQ_address/152] = 3;
 707   6                  break;
 708   6                } 
 709   5                case 4:       //·çËÙÖÐ
 710   5                {
 711   6                  air_speed[RQ_address/152] = 2;
 712   6                  break;
 713   6                } 
 714   5                case 5:       //·çËÙµÍ
 715   5                {
 716   6                  air_speed[RQ_address/152] = 1;
 717   6                  break;
 718   6                }   
 719   5                case 6:       //·çËÙµÍ
 720   5                {
 721   6                  air_speed[RQ_address/152] = 1;
 722   6                  break;
 723   6                } 
 724   5                default:
 725   5                  air_speed[RQ_address/152] = 1;
 726   5                  break;
 727   5              }
 728   4            }
 729   3            case RQ_mode:   //Êµ¼ÊÎª²éÑ¯¿ª¹Ø»ú×´Ì¬
 730   3            {
 731   4              air_power[RQ_address/152] = BUF_RECE[3];
 732   4              break;
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 13  

 733   4            }
 734   3            case RQ_temperature://Êµ¼ÊÎª²éÑ¯Ä£Ê½
 735   3            {
 736   4              i = BUF_RECE[4];
 737   4              switch(i)
 738   4              {
 739   5                case 1:       //Ä£Ê½¼ÓÈÈ
 740   5                {
 741   6                  air_mode[RQ_address/152] = 3;
 742   6                  break;
 743   6                }
 744   5                case 2:       //Ä£Ê½ÖÆÀä
 745   5                {
 746   6                  air_mode[RQ_address/152] = 2;
 747   6                  break;
 748   6                }   
 749   5                default:        //Ä£Ê½¸ÉÔï£¬µ±ËÍ·çÄ£Ê½
 750   5                {
 751   6                  air_speed[RQ_address/152] = 1;
 752   6                  break;
 753   6                }   
 754   5              }         
 755   4            }
 756   3          }
 757   2        }
 758   1        else if(BUF_RECE[1] == 0X04)
 759   1            { 
 760   2              if(BUF_RECE[2] != ((Modbus_Rcvd_Num-5)))
 761   2                return;
 762   2              if(modbus_state == RQ_speed)
 763   2              {
 764   3                address = (uint16) (BUF_RECE[3]<<8)|BUF_RECE[4];
 765   3                if((address&0x8000)!=0x8000)
 766   3                {
 767   4                  if((address&0x7800)!=0)
 768   4                  {
 769   5                    address &= 0x07ff;
 770   5                    actual_temperature[RQ_address/156] = (uint8) (address/50);
 771   5                  }
 772   4                  else
 773   4                  {
 774   5                    actual_temperature[RQ_address/156] = (uint8) (address/100);
 775   5                  }
 776   4                }
 777   3                else
 778   3                {
 779   4                  actual_temperature[RQ_address/156] = 0;
 780   4                }
 781   3              }
 782   2            }
 783   1      }
 784          
 785          
 786          void main()
 787          {
 788   1        unsigned char   data  i,j;
 789   1        unsigned char   air_box_index,RQ_TIMES;
 790   1      //  uint8 temp_mdbs_data;
 791   1      //  uint8 sv_data[2];
 792   1        uint16 buf_index;
 793   1        
 794   1      //  uint16 modbus_reg_addr,modbus_rqst_len;
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 14  

 795   1        
 796   1      
 797   1      
 798   1        //struct  Task_d   xdata *Task_point;
 799   1      
 800   1          PCA0MD &= ~(0x40);      // clear Watchdog Enable bit
 801   1        Init_Device();
 802   1          init_Modbus_Reg();   
 803   1        TR1 = ON;
 804   1        TR0 = ON;
 805   1        EA  = ON;
 806   1        OE0 = ON;
 807   1        RI0 = ON;
 808   1              OE1 = ON;
 809   1              SCON1  |=0x01;
 810   1          
 811   1      //    flag_first_run = 0;        
 812   1          status_device_first_run = 1;
 813   1              for(box=0;box<255;box++)
 814   1              {
 815   2                Delay_ms(60);
 816   2              }
 817   1          /*
 818   1          for(box=0;box<5;box++)
 819   1          {
 820   1            air_box[box] = box;
 821   1            power_ip[box] = box;  
 822   1          }
 823   1          air_box[5] = 0xff;
 824   1          power_ip[5] = 0xff;
 825   1          */
 826   1      //    WriteEE(0x360,6,air_box);
 827   1      //    WriteEE (0x370,6,power_ip);
 828   1                 
 829   1                ReadEE(0x01,1,RTC_BUF);
 830   1                box = RTC_BUF[0];
 831   1              ReadEE(0x235,3,RTC_BUF);
 832   1      /**********************************************************************/
 833   1      /*  EEPROMÖÐµØÖ·0x235 modbus´Ó»úµÄµØÖ·                  */
 834   1      /*          0x400 º£¶ûÄÚ»ú¶ÔÓ¦µÄboxºÅ               */
 835   1      /**********************************************************************/
 836   1          station_ip = RTC_BUF[0];
 837   1          control_mode = RTC_BUF[1];
 838   1          poling_mode = RTC_BUF[2];
 839   1          ReadEE(0x400,64,air_box_num);
 840   1      //    control_mode = 0;//¹ã²¥Ä£Ê½»òÕßÊÇµ¥¿ØÄ£Ê½
 841   1          if(control_mode == 0xff)
 842   1            status_no_other_dakin_vrv = 1;
 843   1          else 
 844   1            status_no_other_dakin_vrv = 0;
 845   1      //    ReadEE(0x360,16,air_box);
 846   1      //    ReadEE(0x370,16,VRV_ip);
 847   1      //    for(i=0;i<16;i++)
 848   1      //    {
 849   1      //      if((VRV_ip[i]<=0x4f)&&(VRV_ip[i]>0x0f))
 850   1      //      /****************************************/
 851   1      //      /*    VRV¿Õµ÷µØÖ·Îª1-00µ½4-15     */  
 852   1      //      /****************************************/
 853   1      //        status_vrv_pointed = 1;
 854   1      //    }
 855   1      
 856   1      //  station_ip  = 1;
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 15  

 857   1      //  RTC_BUF[0] = 1;
 858   1      //  ReadEE(0x351,1,RTC_BUF);
 859   1      //  station_ip = RTC_BUF[0];
 860   1      //  station_ip = 0x01;
 861   1      //  svd_air_param[0][2] = 0xf0cc;
 862   1            
 863   1        BUF_TRCE1[0] = 0xfa;
 864   1        BUF_TRCE1[1]=  DEVICE_CODE;
 865   1        BUF_TRCE1[2]=  box;
 866   1        BUF_TRCE1[3]=  0xfe;
 867   1        BUF_TRCE1[4]=  0xef;    //modbus ×ª»»Æ÷
 868   1        BUF_TRCE1[5]=  0x11/*ver*/;
 869   1        BUF_TRCE1[6]=  0x80;
 870   1        trans_data1();
 871   1        
 872   1        /*********
 873   1        ver : 0x10 dakin modbus
 874   1        
 875   1        ************/
 876   1        
 877   1        
 878   1        time20ms=10;
 879   1        
 880   1        second  =50;
 881   1          
 882   1      
 883   1        
 884   1        PCA0CN    = 0x40;
 885   1        
 886   1        PCA0L    = 0x00;                // Set lower byte of PCA counter to 0  
 887   1        PCA0H    = 0x00;                // Set higher byte of PCA counter to 0
 888   1        
 889   1        PCA0CPL4 = 0xFF;     // Write offset for the WDT 
 890   1        
 891   1      //  PCA0MD |= 0x60;      // enable Watchdog Enable bit
 892   1          
 893   1        PCA0CPH4 = 0xff;
 894   1        
 895   1        COM0_length = 7;
 896   1      
 897   1      //  initial_reg_len();
 898   1      //  request_preset();
 899   1        PCA0MD |= 0x60;      // enable Watchdog Enable bit 
 900   1      
 901   1      //01 03 01 00 00 08 45 F0
 902   1      //01 03 10 00 08 82 00 00 15 00 01 16 82 96 00 00 00 00 02 99 98 
 903   1      //  if(status_no_other_dakin_vrv ==0)
 904   1      //  {
 905   1      //    BUF_RECE[0] = station_ip;
 906   1      //    BUF_RECE[1] = 0X06;
 907   1      //    BUF_RECE[2] = 0X00;
 908   1      //    BUF_RECE[3] = 0X00;
 909   1      //    BUF_RECE[4] = 0X81;
 910   1      //    BUF_RECE[5] = 0X0f;
 911   1      //    CRC_result  = crc_chk(BUF_RECE,6);
 912   1      //    BUF_RECE[6] = (uint8) CRC_result;
 913   1      //    BUF_RECE[7] = (uint8) (CRC_result>>8);
 914   1      //    trans_data(); 
 915   1      //    while(!OE0){;}
 916   1      //    
 917   1      //    RTC_BUF[0] = 0XFF;
 918   1      //    WriteEE(0x351,1,RTC_BUF); 
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 16  

 919   1      //  }
 920   1        roll_poling = 0;
 921   1        roll_flag = 1;
 922   1                            
 923   1        do               
 924   1        { 
 925   2      /*************************  added by jin ******************************/
 926   2      /**************  ³¬Ê±£¬±íÊ¾½ÓÊÕÍê³É»òÊÇÔÊÐí·¢ËÍ*******************/
 927   2          if(flag_1ms>=6)//Êý×Ö´ú±íºÁÃë
 928   2          {
 929   3            if(sreceive)
 930   3            {
 931   4              sreceiveend = 1;
 932   4              PermitTrans = 0;
 933   4              sreceive = 0;
 934   4              REN0=0;
 935   4            } 
 936   3            else 
 937   3            {
 938   4              sreceiveend = 0;
 939   4              PermitTrans = 1;
 940   4              REN0 = 1;       
 941   4            }
 942   3            flag_1ms=0; 
 943   3          }
 944   2      /*********************³¬Ê±£¬±íÊ¾½ÓÊÕÍê³É»òÊÇÔÊÐí·¢ËÍ************************/
 945   2      
 946   2      
 947   2          if(sreceiveend)       //´®¿Ú0½ÓÊÕµ½ÁËmodbusÃüÁî
 948   2          {
 949   3            sreceiveend = OFF;
 950   3            /************ ´Ë´¦ÊÇLDSµÄcheckSum modbus²»ÓÃ£¬ÆÁ±ÎÖ®  ***************
 951   3            j=BUF_RECE[0];
 952   3            for(i=1;i<receive_length;i++)
 953   3            {
 954   3              j=j^BUF_RECE[i];
 955   3            }
 956   3            if(!j)  receive_data();
 957   3            /******************************/
 958   3      /************************* added by jin **********************************/
 959   3      /**********************************½ÓÊÕÍê³É²¢×öÐ£Ñé******************************/
 960   3            //º£ÁÖµÄÃæ°åÐ£ÑéÊý¾ÝÊ±µÍÎ»ÏÈ·¢ËÍ£¬¸ßÎ»ºó·¢ËÍµÄ
 961   3            CRC_result = (BUF_RECE[Modbus_Rcvd_Num-1]<<8)|BUF_RECE[Modbus_Rcvd_Num-2];
 962   3      
 963   3            if(CRC_result==crc_chk(BUF_RECE,Modbus_Rcvd_Num-2))
 964   3            {
 965   4      //        if((BUF_RECE[2] == Modbus_Rcvd_Num-5)&&(BUF_RECE[2]%2 == 0))     //½ÓÊÕµ½µÄÊý¾Ý³¤¶ÈÊÇ·ñ·ûºÏ
 966   4      //        ´Ë´¦µÄif±íÊ¾½ÓÊÕµ½µÄmodubsÊý¾Ý³¤¶ÈÊÇÕýÈ·µÄ£¬ÔÚÕâ¸öifÏÂÃæÊÇ´¦Àí³ÌÐò
 967   4                process_received();
 968   4              REN0=1;
 969   4              
 970   4      //        if(status_ctrl == 0)
 971   4              {
 972   5                interval_ms = 0;
 973   5              }
 974   4            }
 975   3          }     
 976   2      
 977   2          //¿ªÊ¼·¢ËÍµÄ³ÌÐò
 978   2          if((PermitTrans==1)&&(readySend==1))   //·¢ËÍ±êÖ¾Î»¶¼ÎªÒ»Ê±£¬¿ªÊ¼·¢ËÍ
 979   2          {
 980   3            PermitTrans=0;
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 17  

 981   3            readySend=0;
 982   3              trans_data();
 983   3            
 984   3          }
 985   2      
 986   2      /**************************************¿ªÊ¼·¢ËÍµÄ³ÌÐò*****************************************/ 
 987   2          
 988   2          if(sreceiveend_1)
 989   2          {
 990   3            sreceiveend_1 = OFF;
 991   3            receive_data1();
 992   3            SCON1 |=0x10;
 993   3          }
 994   2      
 995   2                      if(receive_length==40)
 996   2                      {
 997   3                                  
 998   3                      }           
 999   2          
1000   2          
1001   2          while(TIME_1MS)
1002   2          {
1003   3            TIME_1MS = 0;
1004   3            
1005   3            PCA0CPH4 = 0xff;
1006   3            
1007   3            
1008   3            if(!(--time20ms_out))
1009   3            {
1010   4      
1011   4              time20ms_out = 10;
1012   4              
1013   4              
1014   4              
1015   4            }
1016   3              
1017   3            
1018   3            //PROC_RELAY_OUTPUT();  
1019   3            
1020   3            if(!(--time20ms))
1021   3            {
1022   4      
1023   4              time20ms = 10;
1024   4              if(tranready_1)
1025   4              {
1026   5                tranready_1=0;
1027   5                trans_data1();
1028   5              }
1029   4              
1030   4                    
1031   4              
1032   4        /*service°´Å¥´¦Àí³ÌÐò,service°´Å¥ÊÍ·Å:servicesw=0,service°´Å¥°´ÏÂ:servicesw=1,  */    
1033   4              service_led =1;
1034   4              Delay(2);
1035   4              if(!service_led)
1036   4              {
1037   5                if(!servicesw)
1038   5                { 
1039   6                  servicesw=1;
1040   6                  while(!OE1);
1041   6                  BUF_TRCE1[0] = 0xfa;
1042   6                  BUF_TRCE1[1]=  DEVICE_CODE;
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 18  

1043   6                  BUF_TRCE1[2]=  box;
1044   6                  BUF_TRCE1[3]=  0xfe;
1045   6                  BUF_TRCE1[4]=  0;
1046   6                  BUF_TRCE1[5]=  ver;
1047   6                  BUF_TRCE1[6]=  0;
1048   6                  set_tranready1();
1049   6                } 
1050   5              }
1051   4              else
1052   4              {
1053   5                servicesw=0;
1054   5                if(led_status)service_led =1;
1055   5                else  service_led =0;
1056   5              }
1057   4              
1058   4              if(!second--)
1059   4              {
1060   5                second = 50;
1061   5                
1062   5                if(!setup_mode)clear_wdt();
1063   5                flag_1s^=1;
1064   5      //          flag_1s = 1;
1065   5      
1066   5                if(flag_1s)  
1067   5                {
1068   6                  if(RQ_TIMES == 0)
1069   6                  {
1070   7                    RQ_TIMES = 4;
1071   7                    air_box_index++;
1072   7                    if(air_box_index>63)
1073   7                      air_box_index=0;
1074   7                    for(;air_box_index<64;i++)
1075   7                    {
1076   8                      if(air_box_num[air_box_index]!=0)
1077   8                        break;
1078   8                      else air_box_index++;
1079   8                    }
1080   7                  } 
1081   6                  if(RQ_ST==0)
1082   6                  {
1083   7                    RQ_TIMES--;
1084   7                    RQ_air_condi(air_box_index,1);
1085   7                  }
1086   6                  else
1087   6                  {
1088   7                    if(status_ctrl == 1)
1089   7                    {
1090   8                      status_ctrl=0;
1091   8                      modbus_state = ST_onoff;
1092   8                    }
1093   7                    
1094   7                    if((modbus_state==RQ_onoff)
1095   7                      ||(modbus_state==RQ_mode)
1096   7                      ||(modbus_state==RQ_temperature)
1097   7                      ||(modbus_state==RQ_speed)
1098   7                      ||(modbus_state==RQ_out_state) )
1099   7                    {
1100   8                      modbus_state = ST_onoff;
1101   8                    }
1102   7                    ST_air_condi(air_condi_num,1,Modbus_Reg);
1103   7                  }
1104   6      
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 19  

1105   6      
1106   6                }
1107   5                if((resend_msg)&&(OE0))
1108   5                { 
1109   6                  if(!resend_msg_sec--)
1110   6                  { 
1111   7                  
1112   7                    resend_msg_sec=10;  
1113   7                    for(temp=0;temp < resend_msg_length;temp++)
1114   7                    BUF_RECE[temp] = resend_msg_buf[temp] ;
1115   7                    trans_data();
1116   7                    if(!resend_msg_counter--) resend_msg = 0;
1117   7                  
1118   7                  }
1119   6                }
1120   5                  
1121   5                  
1122   5                if(TRFLAG)
1123   5                {
1124   6                  TRFLAG = 0;
1125   6                  //OE0 = 1;
1126   6                  //REN0 =1;
1127   6                  OE1 = 1;
1128   6                  SCON1 |=0x10;
1129   6                  EA = 1;
1130   6                  
1131   6                }
1132   5                else  TRFLAG =1;
1133   5                if(serviceled)
1134   5                { if(!netactivetime--) serviceled=0;
1135   6                                              }
1136   5                else  
1137   5                {
1138   6                  if(led_status)
1139   6                  { 
1140   7                    service_led = 0;
1141   7                    led_status=0;
1142   7                  }
1143   6                  else
1144   6                  {
1145   7                    service_led = 1;
1146   7                    led_status=1;
1147   7                  }   
1148   6                }
1149   5                  
1150   5              }
1151   4              if(serviceled)
1152   4              {                                  
1153   5                if(second<25) 
1154   5                { service_led =0;
1155   6                  led_status=0;
1156   6                }
1157   5                else 
1158   5                { service_led =1;
1159   6                  led_status=1;
1160   6                }
1161   5              }
1162   4              
1163   4            }
1164   3            
1165   3          }
1166   2        }while(1);
C51 COMPILER V9.50a   MAIN                                                                 11/11/2013 13:34:03 PAGE 20  

1167   1        
1168   1      }
*** WARNING C280 IN LINE 788 OF Main.C: 'j': unreferenced local variable
*** WARNING C280 IN LINE 792 OF Main.C: 'buf_index': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2377    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   1445    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     46      33
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
